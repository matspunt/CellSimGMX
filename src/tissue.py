import numpy as np
import datetime
import glob
import os
import subprocess as sp
import tempfile
from distutils.spawn import find_executable

# NOTES/todo
#
# This  does not need a try/except method as any possible issues will already be caught in the PACKMOL setup
# and we will catch errors when we try to convert the cells to reasonable topologies. 
# 
# Make this code work with the amount of cells specified in the input.json
# Need to fit a box around the .gro file after converting --> think about this, should be in GMX class

class TissueConstruction:
    """
    This class uses different means of constructing a tissue like structure. For all methods, the output 
    of a single PACKMOL CELL is used to populate the tissue matrix, but we can choose standard packing,
    opt for monolayers, sheared tissues, or populate a given volume randomly based on a tolerance. 

    Methods:
    --------
    replicate_cell_on_grid(xyz_file, nr_of_cells, offset):
        Creates standard packing    

    replicate_cell_monolayer(xyz_file, nr_of_cells, offset):
        Creates a monolayer in x- and y-direction (z = 1)
        
    replicate_sheared_cell_layer(xyz_file, nr_of_cells, offset, shearing=0.5):
        Creates a sheared geometry in the y-direction. The amount of shearing can be set by the user.
        
    random_packing_in_box(xyz_file, tolerance, nr_of_cells, box_x, box_y, box_z):
        Uses PACKMOL to fit user specified number of cells in a user specified box volume.      
    """

    @staticmethod
    def replicate_cell_on_grid(xyz_file, nr_of_cells, offset):
        """
        Replicates a cell on a grid through standard packing The method tries to find the optimal 
        packing for the specified number of cells on the smallest grid based on the user defined offset. 
        It would most likely be better to turn the offset into a ratio of the CELL radius, based on the JSON
        inputs. 

        Args:
            xyz_file (str): The path to the input .xyz file containing the original cell.
            nr_of_cells (int): The total number of cells to be generated on the grid.
            offset (float): The offset in Angstrom defines the distance between CELL centers
        """
        with open(xyz_file, 'r') as f:
            lines = f.readlines()

        #parse the .xyz, extract nr atoms, atom names and raw x,y,z coordinates (Angstrom!)
        nr_atoms = int(lines[0].strip())

        atoms = []
        coordinates = []
        for line in lines[2:2+nr_atoms]:
            atom, x, y, z = line.split()
            atoms.append(atom)
            coordinates.append([float(x), float(y), float(z)])

        total_offset = offset * (nr_of_cells - 1)

        #this expression tries to fit the requested number of cells on the smallest grid
        grid_size_x = int(np.ceil(nr_of_cells ** (1/3)))
        grid_size_y = int(np.ceil(nr_of_cells ** (1/3)))
        grid_size_z = int(np.ceil(nr_of_cells ** (1/3)))

        new_atoms = []
        new_coordinates = []

        #generate the new coordinates based on the requested isotropic offset
        for i in range(grid_size_x):
            for j in range(grid_size_y):
                for k in range(grid_size_z):
                    for atom, coord in zip(atoms, coordinates):
                        new_atoms.append(atom)
                        new_coord = np.array(coord) + np.array([i, j, k]) * offset - total_offset / 2
                        new_coordinates.append(new_coord.tolist())

        #the .xyz format is quite finicky, ensure we have reasonable column spacing. 
        max_widths = [max(len(str(c)) for c in col) for col in zip(*new_coordinates)]

        # populate the new .xyz file with the displaced coordinates
        output_lines = [f"{nr_of_cells * nr_atoms}\n", f"Generated by replicating {xyz_file} {nr_of_cells} times.\n"]
        for atom, coord in zip(new_atoms, new_coordinates):
            line = f"{atom:<2s}"
            line += ''.join(f"{c:>{max_widths[i]}.{6}f}" for i, c in enumerate(coord))
            line += "\n"
            output_lines.append(line)

        # Write output file
        new_xyz = xyz_file.replace(".xyz", f"_{nr_of_cells}_standard.xyz")
        with open(new_xyz, 'w') as f:
            f.writelines(output_lines)

        print(f"SUCCESS: an .xyz file with {nr_of_cells * nr_atoms} atoms was created: {new_xyz}")

    @staticmethod
    def replicate_cell_monolayer(xyz_file, nr_of_cells, offset):
        """
        Replicates a cell on a monolayer grid and generates a new .xyz file.

        Identical to "replicate_cell_on_grid" except that the z dimension is restricted to a single layer. 

        Args:
            xyz_file (str): The path to the input .xyz file containing the original cell.
            nr_of_cells (int): The total number of cells to be generated in the monolayer
            offset (float): The offset value to be applied to each cell
        """
        with open(xyz_file, 'r') as f:
            lines = f.readlines()

        # Parse the .xyz file, extract the number of atoms, atom names, and coordinates (in Angstrom)
        nr_atoms = int(lines[0].strip())

        atoms = []
        coordinates = []
        for line in lines[2:2 + nr_atoms]:
            atom, x, y, z = line.split()
            atoms.append(atom)
            coordinates.append([float(x), float(y), float(z)])

        total_offset = offset * (nr_of_cells - 1)

        # Determine the number of cells along each axis
        grid_size_x = int(np.ceil(np.sqrt(nr_of_cells)))
        grid_size_y = int(np.ceil(nr_of_cells / grid_size_x))
        grid_size_z = 1  # Limiting the grid size to 1 layer in the z-direction

        new_atoms = []
        new_coordinates = []

        # Generate the new coordinates based on the offset in x and y
        for i in range(grid_size_x):
            for j in range(grid_size_y):
                for k in range(grid_size_z):
                    for atom, coord in zip(atoms, coordinates):
                        new_atoms.append(atom)
                        new_coord = np.array(coord) + np.array([i, j, k]) * offset - total_offset / 2
                        new_coordinates.append(new_coord.tolist())

        # Determine maximum column widths
        max_widths = [max(len(str(c)) for c in col) for col in zip(*new_coordinates)]

        # Populate the new .xyz file with the displaced coordinates
        output_lines = [f"{nr_of_cells * nr_atoms}\n", f"Generated by replicating {xyz_file} {nr_of_cells} times.\n"]
        for atom, coord in zip(new_atoms, new_coordinates):
            line = f"{atom:<2s}"
            # we have changed how z coordinates are calculated. This fix is ugly but fixes column width problem
            line += ''.join(f"{c:>{max_widths[i]}.{6}f}{'        ' if i == 1 else ''}" for i, c in enumerate(coord))
            line += "\n"
            output_lines.append(line)

        # Write the output file
        new_xyz = xyz_file.replace(".xyz", f"_{nr_of_cells}_monolayer.xyz")
        with open(new_xyz, 'w') as f:
            f.writelines(output_lines)

        print(f"SUCCESS: an .xyz file with {nr_of_cells * nr_atoms} atoms was created: {new_xyz}")

    @staticmethod
    def replicate_sheared_cell_layer(xyz_file, nr_of_cells, offset, shearing=0.5):
        """
        Identical to 'replicate_cell_on_grid' except for standard packing, we now allow a displacement
        in the y-direction for the different CELL layers. By default, the shearing is set to 0.5 which
        places the centers of sheared cells exactly inbetween the centers of the unsheared layers. 

        Args:
            xyz_file (str): The path to the input .xyz file containing the original cell.
            nr_of_cells (int): The total number of cells to be generated in the monolayer
            offset (float): The offset value to be applied to each cell
            shearing (float): Determines to what degree the cells are shifted from each other
        """
        
        with open(xyz_file, 'r') as f:
            lines = f.readlines()

        # Parse the .xyz, extract the number of atoms, atom names, and raw x,y,z coordinates (Angstrom!)
        # we need to separately extract the coordinates since y-coordinates are treated differently
        nr_atoms = int(lines[0].strip())

        atoms = []
        x_coordinates = []
        y_coordinates = []
        z_coordinates = []
        for line in lines[2:2+nr_atoms]:
            atom, x, y, z = line.split()
            atoms.append(atom)
            x_coordinates.append(float(x))
            y_coordinates.append(float(y))
            z_coordinates.append(float(z))

        total_offset = offset * (nr_of_cells - 1)

        # This expression tries to fit the requested number of cells on the smallest grid
        grid_size_x = int(np.ceil(nr_of_cells ** (1/3)))
        grid_size_y = int(np.ceil(nr_of_cells ** (1/3)))
        grid_size_z = int(np.ceil(nr_of_cells ** (1/3)))
        # using separate vector grids since we are applying offsets differently to y-direction 
        
        new_atoms = []
        new_x_coordinates = []
        new_y_coordinates = []
        new_z_coordinates = []

        # Generate the new coordinates based on the requested offset in each direction
        for i in range(grid_size_x):
            for j in range(grid_size_y):
                for k in range(grid_size_z):
                    for atom, x, y, z in zip(atoms, x_coordinates, y_coordinates, z_coordinates):
                        new_atoms.append(atom)
                        new_x_coord = x + i * offset - total_offset / 2
                        # every even layer is unsheared, uneven layers have the shearing factor applied
                        # This should work for any number of layers!
                        new_y_coord = y + j * offset + (k % 2) * shearing * offset - total_offset / 2
                        new_z_coord = z + k * offset - total_offset / 2
                        new_x_coordinates.append(new_x_coord)
                        new_y_coordinates.append(new_y_coord)
                        new_z_coordinates.append(new_z_coord)

        # Populate the new .xyz file with the displaced coordinates
        output_lines = [f"{nr_of_cells * nr_atoms}\n", f"Generated by replicating {xyz_file} {nr_of_cells} times.\n"]
        for atom, x, y, z in zip(new_atoms, new_x_coordinates, new_y_coordinates, new_z_coordinates):
            line = f"{atom:<2s}    {x:<12.6f}       {y:<12.6f}       {z:<12.6f}\n"
            output_lines.append(line)

        # Write output file
        new_xyz = xyz_file.replace(".xyz", f"_{nr_of_cells}_sheared.xyz")
        with open(new_xyz, 'w') as f:
            f.writelines(output_lines)

        print(f"SUCCESS: an .xyz file with {nr_of_cells * nr_atoms} atoms was created: {new_xyz}")

    @staticmethod
    def random_packing_in_box(xyz_file, tolerance, nr_of_cells, box_x, box_y, box_z):
        """
        Uses Packmol to fit the specified number of cells randomly in a given box volume. This is a dirty solution. 
        
        Args:
            tolerance (float): The tolerance for packing. Tolerance of 8 seems to give decent results. 
            nr_of_cells (int): The number of cells to fit in the box_volume
            box_x (float): The x dimension of the box in Angstrom. 
            box_y (float): The y dimension of the box in Angstrom.
            box_z (float): The z dimension of the box in Angstrom. 
        """
        #reusing the same logic from Packmol.run_packmol_single_CELL() so don't need to check for availability of PACKMOL again
        packmol_path = find_executable("packmol") 

        input_string = f"tolerance {tolerance} \nfiletype xyz \noutput CELL_{nr_of_cells}_random_packing.xyz\n\nstructure {xyz_file} \n   number {nr_of_cells} \n   inside box 0. 0. 0. {box_x}. {box_y}. {box_z}.\nend structure"
        
        packmol_inp = tempfile.NamedTemporaryFile(mode="w", delete=False, prefix="packmol-", suffix=".inp")
        packmol_inp.write(input_string)
        packmol_inp.close()
        now = datetime.datetime.now()
        log_file = "PACKMOL_random_insertion-{}.log".format(now.strftime("%H-%M-%S"))
        with open(log_file, "w") as f:
            try:
                proc = sp.Popen("{} < {}".format(packmol_path, packmol_inp.name), stdout=sp.PIPE, universal_newlines=True, shell=True)
                for line in proc.stdout:
                    f.write(line)
                    if 'Current solution written to file' in line:
                        #the first solution PACKMOL gives is good enough if we set the tolerance high
                        print(f"SUCCESS: 'CELL_{nr_of_cells}_random_packing.xyz' is created. A logfile is saved at: {log_file}")
                        proc.terminate()
                        break #cancel the run if an intermittent coordinate file has been written. 
                proc.wait(timeout=60)
            except sp.TimeoutExpired:
                print("ERROR: Packmol took longer than 60 seconds to run, this is highly unusual and suggests the packing could not be resolved.")
                print("Most likely the cell radius and/or the number of particles are incorrectly defined in your input.JSON")

#note, the offset in all cases is given in angstrom since we are using the .xyz format
#TissueConstruction.replicate_cell_on_grid('CELL.xyz', 27, 40)
TissueConstruction.replicate_cell_on_grid('CELL.xyz', 8, 50)
#TissueConstruction.replicate_cell_monolayer('CELL.xyz', 2, 40)
#TissueConstruction.replicate_sheared_cell_layer('CELL.xyz', 54, 40, shearing=0.5)
#TissueConstruction.random_packing_in_box('CELL.xyz', tolerance = 8, nr_of_cells = 40, box_x = 150, box_y = 150, box_z = 150)
